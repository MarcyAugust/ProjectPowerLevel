"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bot = void 0;
var tslib_1 = require("tslib");
var twitch_1 = require("twitch");
var twitch_auth_1 = require("twitch-auth");
var twitch_chat_client_1 = require("twitch-chat-client");
var BotCommandContext_1 = require("./BotCommandContext");
var Bot = /** @class */ (function () {
    function Bot(api, _a) {
        var _this = this;
        var channel = _a.channel, channels = _a.channels, debug = _a.debug, commands = _a.commands, prefix = _a.prefix;
        this.api = api;
        this._commands = new Map();
        this._prefix = prefix !== null && prefix !== void 0 ? prefix : '!';
        var resolvableChannels = channel ? [channel] : channels;
        if (!resolvableChannels) {
            throw new Error("didn't pass channel nor channels option, exiting");
        }
        this._commands = new Map(commands === null || commands === void 0 ? void 0 : commands.map(function (cmd) { return [cmd.name, cmd]; }));
        this.chat = new twitch_chat_client_1.ChatClient(api, { logLevel: debug ? twitch_chat_client_1.LogLevel.DEBUG : twitch_chat_client_1.LogLevel.ERROR, channels: channels });
        this.chat.onPrivmsg(function (currentChannel, user, message, msg) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var match;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        match = this.findMatch(msg);
                        if (!(match !== null)) return [3 /*break*/, 2];
                        return [4 /*yield*/, match.command.execute(match.params, new BotCommandContext_1.BotCommandContext(this.chat, msg))];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        }); });
        void this.chat.connect();
    }
    Bot.create = function (config) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.bind;
                        return [4 /*yield*/, this._createApiClientForConfig(config)];
                    case 1: return [2 /*return*/, new (_a.apply(this, [void 0, _b.sent(), config]))()];
                }
            });
        });
    };
    Bot._createApiClientForConfig = function (config) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var info;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!config.client) return [3 /*break*/, 1];
                        return [2 /*return*/, config.client];
                    case 1:
                        if (!config.auth) return [3 /*break*/, 5];
                        if (!(typeof config.auth === 'string')) return [3 /*break*/, 3];
                        return [4 /*yield*/, twitch_auth_1.getTokenInfo(config.auth)];
                    case 2:
                        info = _a.sent();
                        return [2 /*return*/, new twitch_1.ApiClient({ authProvider: new twitch_auth_1.StaticAuthProvider(info.clientId, config.auth, info.scopes) })];
                    case 3: return [2 /*return*/, new twitch_1.ApiClient({ authProvider: config.auth })];
                    case 4: return [3 /*break*/, 6];
                    case 5: throw new Error("didn't pass client nor auth option, exiting");
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    Bot.prototype.findMatch = function (msg) {
        var e_1, _a;
        var line = msg.params.message.trim().replace(/  +/g, ' ');
        try {
            for (var _b = tslib_1.__values(this._commands.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var command = _c.value;
                var params = command.match(line, this._prefix);
                if (params !== null) {
                    return {
                        command: command,
                        params: params
                    };
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return null;
    };
    return Bot;
}());
exports.Bot = Bot;
